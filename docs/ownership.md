# ownership (소유권)


## 메모리 관리
메모리라는 자원은 한정되어 있기 때문에 프로그래밍 언어들은 각자의 방식으로 이 메모리를 효율적으로 관리

### 메모리 구조(스택과 힙)
- 스택: 스택 영역은 함수가 실행될 때 사용하는 메모리 공간으로, 함수에서 사용하는 지역 변수가 스택에 저장됩니다. 일반적으로 스택에서 사용될 메모리 공간이 미리 정해지기 때문에 매우 빠르게 값을 저장하고 접근할 수 있습니다. 만일 함수 실행이 종료되면 스택 영역에서 사용된 모든 지역 변수는 메모리에서 삭제됩니다. 
- 힙: 힙 영역은 동적으로 할당되는 메모리를 위해 존재하는 공간으로, 개발자가 명시적으로 특정 크기의 메모리 공간을 사용하겠다고 선언해야 합니다. 만일 해당 메모리 공간이 더 이상 필요하지 않은 경우에는 해당 메모리를 할당 해제해주어야 합니다. 왜냐하면 이미 점유된 메모리 공간은 다른 프로그램이나 스레드에서 사용할 수 없기 때문입니다.



### Python
**`가비지 콜렉터`를 이용해 언어 차원에서 자동으로 메모리를 관리.**
Python은 모든 객체의 데이터를 힙 영역에 저장.

**파이썬은 스택을 사용하지 않고 모든 객체를 힙 영역에 저장**. 이렇게 저장된 객체들은 파이썬에서 가비지 콜렉션을 통해 메모리를 관리하기 때문에 파이썬을 사용할 때는 메모리 관리에 신경쓰지 않아도 됩니다. 위에서 힙 영역에 대해서 설명할 때 언급한 개발자가 **할당하고 할당 해제하는 메모리를 파이썬의 가비지 콜렉터가 대신**해주는 것입니다.


이 가비지 컬렉터가 런타임에 사용되지 않는 객체가 있으면 주기적으로 객체를 삭제
또는 메모리 사용량이 너무 높은 경우에도 삭제.

> 드디어 '가비지 컬렉터' 라는 용어가 나왔다. 
> docs/Intro_why_rust.md 의 <CPU 연산이 많이 필요한 코드를 러스트로 교체하면 빠르게 동작하는 프로그램을 만들 수 있습니다.> 에서  러스트와 자주 비교되는 언어인 고(Go)와 다르게, 러스트에는 소유권(ownership) 모델을 사용해서  가비지 콜렉터가 없기 때문에 훨씬 좋은 성능을 내게 됩니다. 이러한 특징 때문에 퍼포먼스가 매우 중요한 서비스에 자주 사용됩니다.
> 라는 말에 대해서 이제야 이해할 준비가 되었다. 

위 '러스트에는 소유권(ownership) 모델을 사용해서  가비지 콜렉터가 없기 때문에 훨씬 좋은 성능을 내게 됩니다.' 라는 말을 거꾸로 하면 Python에서는 가비지 컬렉터가 메모리를 관리하기 때문에 성능이 떨어진다.(느리다.) 가 된다. 
가비지 컬렉터가 무슨 영향을 주길래 느려지는 걸까? 
이유는 
1. 가비지 콜렉션이 수행되는 동안에는 다른 파이썬 코드가 실행될 수 없기 때문에 파이썬의 코드 실행 속도가 느려지는 원인이 됩니다. 
2. 어떤 객체가 언제 메모리에서 할당 해제되는지를 개발자가 명시적으로 알 수 있는 방법이 없고 가비지 콜렉터가 이를 전담하기 때문에 프로그램이 불필요하게 많은 메모리를 사용할 가능성도 있습니다.

### Rust
**`소유권(Ownership)`이라는 개념을 통해 메모리를 관리**

**러스트는 스택 영역과 힙 영역 모두를 사용**합니다. 러스트는 기본적으로 아래와 같이 **함수에서 사용하는 모든 값을 제한된 크기의 스택 영역에 저장**합니다. 따라서 함수 호출이 종료되면 지역 변수 foo 와 var는 모두 삭제됩니다.
```rust
fn foo() {
    let foo = "foo";
    let var = 5;
}
```
**힙 영역은 함수에서 명시적으로 선언하는 경우에만 사용**되는데, 힙 영역에 저장하는 값은 전역적으로(globally) 접근이 가능합니다. 나중에 배울 Box 타입을 사용해 선언하면 됩니다. 그리고 **멀티스레딩에서 여러 스레드가 접근하는 변수의 값은 힙 영역에 저장**되게 됩니다.

```rust
fn main() {
    let num = Box::new(1);
}
```

> 가비지 컬렉터 측면 뿐만 아니라 소유권 개념이 주는 장점
> - 메모리 안전성: 메모리 안전성이란, 하나의 값에 대해서 단 하나의 코드만 접근하기 때문에 예상치 못하게 값이 변경되는 일이 없다는 의미
> - 스레드 안전성이 보장:  여러 개의 스레드에서 하나의 값에 접근하고자 할 때 발생할 수 있는 경합 조건(Race condition)이나 데드락(Deadlock)이 발생하지 않는다는 의미입니다. 이 두 가지 문제가 멀티스레딩 프로그램을 만들 때 가장 어렵고 복잡한 문제이지만 러스트에서는 이를 컴파일 타임에 탐지할 수 있기 때문에 안정성이 보장됩니다.


